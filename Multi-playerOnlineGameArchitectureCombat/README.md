# 第1章 网络编程基础

## 1.1 单机游戏与网络游戏的区别

1. 第一个需要了解的概念是“异步”。与“异步”一起出现的概念有“同 步”“并行”（并发）等，这几个概念往往比较容易混淆。 举一个加载的例子，如果需要加载几个不同的资源，先加载A，等到A加载 完成后再加载B，加载完B，再加载C，直到所有资源加载完成，这就是同步操 作。以同步方式实现加载，加载者必须等到加载完成之后才能继续后续的加 载。 如果用3个线程同时加载A、B、C资源，由于线程之间是不会相互影响的， 加载A的同时另外两个线程在加载B和C，这就是并行操作。但这种情况不能算是 异步，因为在加载A时，要等待A加载完成之后退出线程。这个等待产生了阻 塞。 那么，什么是异步呢？异步不会等待，也不会阻塞。 假设加载一个资源需要10秒，加载3个资源，在串行时需要30秒，在并行时 需要10秒，异步也需要10秒。

2. 那么，异步与并行的差别在哪里呢?以图1-4为例来看一下异步的流程。在第N帧发出了加载A命令，这一帧会马 上结束，不需要等待10秒，直接进入下一帧，不关心A是否加载成功，当它加载 成功之后，会在某一帧收到加载成功的回调。因为是异步，同时加载A、B时， 得到结果的顺序可能是不一样的，可能A先发出加载命令，但是B的回调却先发生

   ![20240611140906](./20240611140906.png)

3. 那么，程序是如何知道回调完成的呢？一般来说，有两种方式可以知道A是 否加载成功：
   1.  主动询问，每间隔一段时间询问A是否加载完成。
   2. 被动接收，一般在启动事件时会要求注册一个回调函数，事件完成时 会主动调用回调函数，以标记事件完成。
4.  所谓异步，简而言之，就是在不阻塞进程的情况下完成操作。

## 1.2 理解IP地址

1. 我们看到的IP地址通常是4个十进制数，以“.”隔开，每个十进制数不超 过255。

## 1.3 理解TCP/IP

## 1.4 阻塞式网络编程

### 1.4.1 工程源代码

### 1.4.2 服务端代码分析

### 1.4.3 客户端代码分析

### 1.4.4 系统差异

### 1.4.5 网络底层函数说明

### 1.4.6 小结

## 1.5 非阻塞网络编程

### 1.5.1 工程源代码

### 1.5.2 服务端代码分析

### 1.5.3 客户端代码分析

### 1.5.4 小结

## 1.6 总结

# 第2章 网络IO多路复用

## 2.1 Select网络模型

### 2.1.1 ::select函数说明

### 2.1.2 工程源代码

### 2.1.3 网络基类:Network

### 2.1.4 NetworkListen分析

### 2.1.5 Server流程详解

### 2.1.6 NetworkConnector分析

### 2.1.7 测试流程详解

### 2.1.8 ConnectObj分析

### 2.1.9 Buffer分析

### 2.1.10 RecvNetworkBuffer分析

### 2.1.11 SendNetworkBuffer分析

### 2.1.12 Packet分析

### 2.1.13 小结

## 2.2 Epoll网络模型

### 2.2.1 函数说明

### 2.2.2 源代码分析

### 2.2.3 小结

## 2.3 网络协议:protobuf

### 2.3.1 在Windows下编译使用protobuf

### 2.3.2 在Linux下编译使用protobuf

### 2.3.3 使用protobuf定义协议

## 2.4 总结

# 第3章 线程、进程以及Actor模型

## 3.1 游戏架构概述

### 3.1.1 无服务端游戏

### 3.1.2 单进程CS架构

### 3.1.3 多进程CS架构

## 3.2 框架瓶颈

### 3.2.1 滚服游戏

### 3.2.2 副本游戏

### 3.2.3 大图分割空间游戏

## 3.3 设计游戏框架

## 3.4 游戏主循环

## 3.5 理解进程和线程

### 3.5.1 进程是什么

### 3.5.2 线程是什么

### 3.5.3 C++标准线程库

## 3.6 Actor模型

## 3.7 游戏框架中的线程

### 3.7.1 包裹类ThreadObject

### 3.7.2 线程类Thread

### 3.7.3 线程管理类ThreadMgr

### 3.7.4 libserver库与游戏逻辑

## 3.8 Actor对象之间的消息处理机制

### 3.8.1 消息定义原则

### 3.8.2 消息队列机制

## 3.9 总结

# 第4章 账号登录与验证

## 4.1 登录流程图

## 4.2 制作一个简单的验证接口

### 4.2.1 Nginx参考配置

### 4.2.2 php-fpm参考配置

## 4.3 导入PHP登录接口

### 4.3.1 修改PHP中的数据库配置

### 4.3.2 导入测试账号

### 4.3.3 批量生成账号

## 4.4 编码中用到的第三方库

### 4.4.1 库libcurl

### 4.4.2 库libjsoncpp

## 4.5 账号验证代码分析

### 4.5.1 定义登录协议号

### 4.5.2 处理协议的Account类

### 4.5.3 Account类如何放置到线程中

### 4.5.4 处理验证的HttpRequestAccount类

## 4.6 结果测试

## 4.7 消息过滤机制

## 4.8 测试机器人

### 4.8.1 状态机

### 4.8.2 状态机基类

### 4.8.3 状态机管理类

### 4.8.4 Robot类中的状态机

## 4.9 批量登录测试

## 4.10 总结

# 第5章 性能优化与对象池

## 5.1 Visual Studio性能工具

## 5.2 内存中的数据结构

### 5.2.1 交换型数据结构

### 5.2.2 刷新型数据结构

## 5.3 gprof

### 5.3.1 gprof调用堆栈图

### 5.3.2 让进程安全退出

### 5.3.3 用gprof工具查看框架

## 5.4 valgrind

## 5.5 对象池

### 5.5.1 对象池代码分析

### 5.5.2 使用cmd命令查看对象池

## 5.6 总结

# 第6章 搭建ECS框架

## 6.1 一个简单的ECS工程

### 6.1.1 组件类Component

### 6.1.2 实体类Entity

### 6.1.3 系统类System

### 6.1.4 管理类EntitySystem

### 6.1.5 测试

## 6.2 基于ECS框架的libserver

### 6.2.1 通过字符串动态创建类

### 6.2.2 提供多参变量来创建实例

### 6.2.3 EntitySystem的工作原理

## 6.3 基于ECS框架的login和robots工程

### 6.3.1 Account类

### 6.3.2 动态创建组件或实例

### 6.3.3 ECS框架下的网络通信

### 6.3.4 执行效率

## 6.4 YAML文件

### 6.4.1 YAML编译安装

### 6.4.2 读取YAML配置文件

### 6.4.3 合并线程

## 6.5 log4cplus日志

### 6.5.1 log4cplus的编译安装

### 6.5.2 配置文件

### 6.5.3 使用log4cplus

## 6.6 总结

# 第7章 MySQL数据库

## 7.1 MySQL Connector/C

## 7.2 连接时使用的函数说明

## 7.3 数据库连接组件

### 7.3.1 MysqlConnector组件

### 7.3.2 连接数据库

### 7.3.3 关闭连接

## 7.4 写入数据时使用的函数说明

## 7.5 写入数据示例

### 7.5.1 创建预处理

### 7.5.2 用预处理创建角色

## 7.6 查询数据时使用的函数说明

## 7.7 查询数据示例

### 7.7.1 Query查询函数

### 7.7.2 查询玩家数据

## 7.8 数据表的创建与更新

### 7.8.1 创建表

### 7.8.2 更新表

### 7.8.3 测试更新与创建组件

## 7.9 数据表中的数据结构与protobuf结构

## 7.10 角色查询与创建流程

### 7.10.1 为login进程与dbmgr进程创建连接类

### 7.10.2 找到指定的NetworkConnector实例

### 7.10.3 创建角色

### 7.10.4 机器人登录创建角色测试

## 7.11 总结

# 第8章 深入学习组件式编程

## 8.1 新的系统管理类SystemManager

### 8.1.1 实体系统EntitySystem

### 8.1.2 更新系统UpdateSystem

### 8.1.3 消息系统MessageSystem

### 8.1.4 测试执行效率

## 8.2 allinone工程

### 8.2.1 新工程allinone

### 8.2.2 协议是如何被转发的

### 8.2.3 查看线程中的所有对象

### 8.2.4 测试执行效率

## 8.3 线程分类

## 8.4 IAwakeSystem接口与对象池

### 8.4.1 DynamicObjectPoolCollector对象池集合

### 8.4.2 全局单例对象

### 8.4.3 查看线程中的所有对象

## 8.5 主动销毁对象

### 8.5.1 一般组件销毁

### 8.5.2 引用计数销毁对象

## 8.6 时间堆

### 8.6.1 堆实现代码

### 8.6.2 时间堆组件

## 8.7 总结

# 第9章 服务器管理进程与HTTP

## 9.1 启动多个login进程

## 9.2 appmgr进程

## 9.3 HTTP

## 9.4 使用Mongoose分析HTTP格式

### 9.4.1 HTTP类型

### 9.4.2 接收HTTP数据

### 9.4.3 处理HTTP数据的协议号

### 9.4.4 收到HTTP请求是如何响应的

### 9.4.5 发送HTTP返回数据流程

## 9.5 为Packet定义新的网络标识

### 9.5.1 使用网络标识创建一个连接

### 9.5.2 使用网络标识发送数据

### 9.5.3 向外部请求HTTP数据

## 9.6 HTTP分块

## 9.7 机器人测试批量登录

## 9.8 总结

# 第10章 分布式登录与Redis内存数据库

## 10.1 game与space的定位

### 10.1.1 选择合适的game进程

### 10.1.2 使用token登录game进程

### 10.1.3 Player组件

## 10.2 Redis及其第三方库

### 10.2.1 Redis的安装

### 10.2.2 Redis命令行命令

### 10.2.3 hireids库

### 10.2.4 组件RedisConnector

### 10.2.5 Redis在login中的应用

### 10.2.6 Redis在game中的应用

### 10.2.7 从Redis删除数据

## 10.3 性能瓶颈分析

### 10.3.1 使用日志查看瓶颈

### 10.3.2 优化MessageComponent组件

### 10.3.3 ConnectObj内存组织

## 10.4 多进程登录协议回顾

## 10.5 总结

# 第11章 分布式跳转方案

## 11.1 资源数据配置与读取

### 11.1.1 资源管理类ResourceManager

### 11.1.2 地图资源管理类ResourceWorldMgr

### 11.1.3 地图资源类ResourceWorld

## 11.2 地图类World与代理类WorldProxy

### 11.2.1 地图类World

### 11.2.2 为什么需要WorldProxy

## 11.3 分布式地图跳转流程

### 11.3.1 发起跳转协议的时机

### 11.3.2 跳转协议的数据定义

### 11.3.3 目标代理地图收到跳转协议

### 11.3.4 网络标识如何在网络中传递

### 11.3.5 space进程发送的协议如何转发到客户端

## 11.4 通过客户端进入游戏

## 11.5 玩家在WorldProxy之间的跳转

## 11.6 总结

# 第12章 断线与动态加载系统

## 12.1 玩家断线

### 12.1.1 玩家在login进程中断线

### 12.1.2 玩家在game进程中断线

### 12.1.3 玩家断线时World类的处理

### 12.1.4 玩家数据的读取与保存

### 12.1.5 如何进入断线之前的地图

## 12.2 进程之间的断线

### 12.2.1 login进程断线与重连

### 12.2.2 game进程断线与重连

### 12.2.3 space进程断线与重连

### 12.2.4 appmgr进程断线与重连

## 12.3 动态新增系统

### 12.3.1 MoveComponent组件

### 12.3.2 新系统MoveSystem

### 12.3.3 加载新系统

### 12.3.4 测试移动

## 12.4 总结

# 写在最后——如何构建自己的框架

# 附录A 在CentOS上建立开发环境
