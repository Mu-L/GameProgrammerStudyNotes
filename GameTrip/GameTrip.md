第1章 计算机，游戏，我 1

1.1 计算机 2

1.2 计算机游戏 3

1.3 计算机与我 7

1.3.1 启蒙 7

1.3.2 编程 9

第2章 算法，程序的灵魂 13

2.1 程序=算法+数据结构 14

2.1.1 算法 15

2.1.2 数据结构 17

2.2 搜索算法 23

2.2.1 地图寻路问题 23

2.2.2 博弈问题 27

2.2.3 更为广泛的运用 28

2.3 智能算法 29

2.3.1 遗传算法（Genetic Algorithm） 29

2.3.2 [模拟退火算法](https://baike.baidu.com/item/模拟退火算法/355508?fromModule=lemma_inlink)（Simulated Annealing） 31

2.3.3 禁忌搜索（Tabu Search） 33

2.3.4 [人工神经网络](https://baike.baidu.com/item/人工神经网络/382460?fromModule=lemma_inlink)

（Artificial Neural Network） 34

2.4 优化 36

2.4.1 质数问题 36

1.4.2 俄罗斯方块竞赛 37

2.5 Apple II上的编程之路 39

第3章 编程语言 45

3.1 C 语言 46

3.2 BASIC 50

3.3 C++ 51

3.4 汇编语言 54

3.4.1 概述 55

3.4.2 程序的本质 57

3.4.3 寄存器 58

3.4.4 寻址方式 60

3.4.5 汇编指令 61

3.4.6 C/C++ 语言和汇编 62

3.4.7 小结 63

3.5 其他语言 63

3.5.1 Forth 63

3.5.2 Lisp 64

3.5.3 Java 64

3.5.4 Python、Lua、更多 65

第4章 前Windows 时代 67

4.1 386保护模式 68

4.2 VGA 到VESA 70

4.2.1 超越 BGI 70

4.2.2 VGA 72

4.2.3 VESA 标准 72

4.2.4 花絮 74

4.3 保护模式下的开发工具 75

4.4 闲话 Allegro 81

4.4.1 用C与汇编写成的程序库 81

4.4.2 BITMAP 82

4.4.3 Sprite 85

4.4.4 几何图形和 3D 89

4.4.5 数据文件 91

4.4.6 声音 92

4.4.7 其他的部分 93

4.4.8 小结 94

4.5 cfido [中国惠多网](https://baike.baidu.com/item/中国惠多网/8802967?fromModule=lemma_inlink) 94

第5章 Windows 编程 101

5.1 Windows编程入门 104

5.1.1 Windows版本综述 105

5.1.2 操作系统的核心 107

5.1.3 Windows API和DLL 110

5.1.4 COM 111

5.1.5 Windows的窗口和消息处理与传递 114

5.1.6 Windows GDI 125

5.2 控制游戏的速度 130

5.3 浅谈MFC 132

5.4 小结 132

第6章 汇编优化 135

6.1 浅谈代码优化 138

6.2 并不仅仅是汇编 139

6.2.1 在算法实现时减少上下文的依赖关系 139

6.2.2 低效的静态变量 140

6.2.3 数据的组织 141

6.2.4 消除除法 142

6.2.5 避免过大的循环 144

6.3 汇编和C/C++的混合编程 146

6.3.1 使用外置的汇编编译器 146

6.3.2 使用内嵌汇编 148

6.3.3 C++的函数调用规则 150

6.3.4 寄存器的使用 152

6.3.5 _declspec(naked) 152

6.4 指令使用的技巧 153

6.4.1 LEA：别样的内存寻址指令 153

6.4.2 BSWAP：扩展寄存器的个数 154

6.4.3 缩短指令的字节数 155

6.4.4 避免跳转指令 159

6.5 Pentium 的汇编优化策略 161

6.5.1 UV流水线 163

6.5.2 AGI地址生成互锁

（Address Generation Interlock） 167

6.5.3 Pentium Pro，Pentium II和Pentium III

的汇编优化策略 168

6.5.4 Pentium 4的汇编优化策略 178

6.5.5 如何测试代码的速度 181

6.5.6 汇编能干的事情 183

第7章 SIMD 指令 185

7.1 单指令多数据编程 186

7.1.1 Alpha 混合 187

7.2 MMX 191

7.2.1 MMX的指令概况 192

7.2.2 SSE及其对MMX的扩展 194

7.2.3 SIMD技术在C语言环境下的使用 196

7.2.4 MMX 编码技巧 197

7.2.5 SIMD 的应用举例 201

7.2.6 SIMD编程注意要点 203

7.2.7 SIMD的性能检测 204

第8章 引擎中的优化 205

8.1 Blit的优化 207

8.2 脏矩形优化 209

8.2.1 “风魂”中改进的脏矩形算法 215

8.2.2 滚动优化 219

8.2.3 覆盖优化 222

8.2.4 脏矩形在3D游戏界面中的运用 224

8.2.5 时间和空间的权衡 229

8.2.6 关于估算 230

8.3 自己设计精灵格式 231

8.4 动态数据加载 234

8.5 小结 236

第9章 C 和 C++ 237

9.1 从C到C++ 239

9.2 C vs C++，效率至上 243

9.2.1 全局变量 243

9.2.2 函数调用的堆栈处理 243

9.2.3 函数调用的参数传递 244

9.2.4 临时变量的堆栈使用 244

9.2.5 代码生成 244

9.2.6 异常 244

9.2.7 inline 245

9.2.8 多态性 245

9.2.9 标准库的差异 245

9.2.10 动态内存分配 245

9.3 优雅的C++ 246

9.3.1 消失了的宏 247

9.3.2 const修饰及类型转换 248

9.3.3 隐藏实现 248

9.3.4 引用而非指针 250

9.3.5 名字空间 250

9.4 C++ 的误区 251

9.4.1 类层次过细 251

9.4.2 滥用操作符重载 252

9.4.3 滥用标准容器 253

9.4.4 滥用动态类型识别和异常 253

9.4.5 滥用多重继承 254

9.4.6 忽视C++高级特性的复杂度 255

9.4.7 学习C++ 256

9.5 动态内存分配的优化 257

9.5.1 另一种优化策略：多次分配，一次释放 266

9.5.2 垃圾回收 268

9.5.3 再论动态内存分配 269

9.6 template 272

9.6.1 封装C++的成员函数调用 272

9.6.2 常数数量的对象复制 274

9.6.3 对象计数 275

9.6.4 避免重复代码 277

9.6.5 选择最佳的容器 279

9.6.6 延迟运算 281

9.6.7 编译时计算的游戏 283

9.7 小结 286

第10章 调试 287

10.1 assert及程序错误的提前发现 288

10.1.1 崩溃的程序不说谎 289

10.1.2 为软件维护多个版本 291

10.1.3 前置条件和后置条件 292

10.1.4 自己实现一个assert 292

10.1.5 不正确的assert使用 293

10.1.6 为assert分级 294

10.1.7 assert的引申：检查函数返回值 295

10.1.8 释放的指针需要置空吗 297

10.2 让程序更利于调试 298

10.2.1 录像 299

10.2.2 实现一个log类 300

10.2.3 跟踪代码运行的流程 302

10.2.4 为内存分配加上一个壳 302

10.3 [RELEASE版本](https://baike.baidu.com/item/RELEASE版本/6497294?fromModule=lemma_inlink)的调试 310

10.4 小结 311

第11章 脚本 313

11.1 为什么需要脚本 314

11.2 应该用脚本做些什么 316

11.3 脚本不应该做什么 318

11.4 如何嵌入脚本语言 319

11.5 选择一种脚本语言 321

11.6 实战嵌入式脚本Lua 5 324

11.6.1 嵌入Lua 324

11.6.2 使用coroutine驱动游戏逻辑 326

11.6.3 封装C++中的对象 328

11.6.4 回调机制 336

11.7 反外挂技术 338

11.7.1 防止加速器 338

11.7.2 防止分析伪造网络包 339

11.7.3 防止逆向工程 341

11.7.4 防止代码钩子 344

11.7.5 惩戒外挂作弊者 344

11.7.6 安全地将信息传递给服务器 345

11.7.7 防止模拟输入 346

第12章 版本控制 349

12.1 常用版本控制软件 351

12.2 版本控制工具在项目中的使用 355

12.3 不仅仅是程序才需要 358

第13章 开发方法 361

13.1 失败的经验 363

13.2 成功的经验 365

13.3 对游戏开发方法的一些思考 369

第14章 编程和游戏 373

14.1 操作 376

14.2 角色设定 378

14.3 再谈技术 379

14.4 浅谈网络游戏 381

14.5 小结 382
