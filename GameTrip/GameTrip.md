# 第1章 计算机，游戏，我

# 第2章 算法，程序的灵魂 

1. 程序=算法+数据结构 

2. 算法 

3. 数据结构 

4. 搜索算法 
   1. 地图寻路问题 
   2. 博弈问题 
   3. 更为广泛的运用 

5. 智能算法
   1. 遗传算法
   2. 模拟退火算法
   3. 禁忌搜索
   4. 人工神经网络

6. 优化
   * 数学方法的改进
   * 预运算来节省时间(空间换时间来避免重复运算)或是重复运算来节省空间。
   * 简化算法求得近似解来取代精确解(或最优解)
   * 改进数据组织方式，用更少的操作处理更多的数据，甚至避免几余数据的处理。



第3章 编程语言 

3.1 C 语言 

3.2 BASIC 

3.3 C++ 

3.4 汇编语言 

3.4.1 概述 

3.4.2 程序的本质 

3.4.3 寄存器 

3.4.4 寻址方式 

3.4.5 汇编指令 

3.4.6 C/C++ 语言和汇编 

3.4.7 小结 

3.5 其他语言 

3.5.1 Forth 

3.5.2 Lisp 

3.5.3 Java 

3.5.4 Python、Lua、更多 

第4章 前Windows 时代 

4.1 386保护模式 

4.2 VGA 到VESA

4.2.1 超越 BGI

4.2.2 VGA

4.2.3 VESA 标准

4.2.4 花絮

4.3 保护模式下的开发工具

4.4 闲话 Allegro

4.4.1 用C与汇编写成的程序库

4.4.2 BITMAP

4.4.3 Sprite

4.4.4 几何图形和 3D

4.4.5 数据文件

4.4.6 声音 92

4.4.7 其他的部分 93

4.4.8 小结 94

4.5 cfido

第5章 Windows 编程 

5.1 Windows编程入门 

5.1.1 Windows版本综述 

5.1.2 操作系统的核心 

5.1.3 Windows API和DLL 

5.1.4 COM 

5.1.5 Windows的窗口和消息处理与传递 

5.1.6 Windows GDI 

5.2 控制游戏的速度 

5.3 浅谈MFC 

5.4 小结 

第6章 汇编优化 

6.1 浅谈代码优化 

6.2 并不仅仅是汇编 

6.2.1 在算法实现时减少上下文的依赖关系 

6.2.2 低效的静态变量 

6.2.3 数据的组织 

6.2.4 消除除法 

6.2.5 避免过大的循环 

6.3 汇编和C/C++的混合编程 

6.3.1 使用外置的汇编编译器 

6.3.2 使用内嵌汇编 

6.3.3 C++的函数调用规则 

6.3.4 寄存器的使用 

6.3.5 _declspec(naked) 

6.4 指令使用的技巧 

6.4.1 LEA：别样的内存寻址指令 

6.4.2 BSWAP：扩展寄存器的个数 

6.4.3 缩短指令的字节数 

6.4.4 避免跳转指令 

6.5 Pentium 的汇编优化策略 

6.5.1 UV流水线 

6.5.2 AGI地址生成互锁

（Address Generation Interlock） 

6.5.3 Pentium Pro，Pentium II和Pentium III

的汇编优化策略 

6.5.4 Pentium 4的汇编优化策略 

6.5.5 如何测试代码的速度 

6.5.6 汇编能干的事情 

第7章 SIMD 指令 

7.1 单指令多数据编程 

7.1.1 Alpha 混合 

7.2 MMX 

7.2.1 MMX的指令概况 

7.2.2 SSE及其对MMX的扩展 

7.2.3 SIMD技术在C语言环境下的使用 

7.2.4 MMX 编码技巧 

7.2.5 SIMD 的应用举例 

7.2.6 SIMD编程注意要点 

7.2.7 SIMD的性能检测 

第8章 引擎中的优化 

8.1 Blit的优化 

8.2 脏矩形优化 

8.2.1 “风魂”中改进的脏矩形算法 

8.2.2 滚动优化 

8.2.3 覆盖优化 

8.2.4 脏矩形在3D游戏界面中的运用 

8.2.5 时间和空间的权衡 

8.2.6 关于估算 

8.3 自己设计精灵格式 

8.4 动态数据加载 

8.5 小结 

第9章 C 和 C++ 

9.1 从C到C++ 

9.2 C vs C++，效率至上 

9.2.1 全局变量 

9.2.2 函数调用的堆栈处理 

9.2.3 函数调用的参数传递 

9.2.4 临时变量的堆栈使用 

9.2.5 代码生成 

9.2.6 异常 

9.2.7 inline 

9.2.8 多态性 

9.2.9 标准库的差异 

9.2.10 动态内存分配 

9.3 优雅的C++ 

9.3.1 消失了的宏 

9.3.2 const修饰及类型转换 

9.3.3 隐藏实现 

9.3.4 引用而非指针 

9.3.5 名字空间 

9.4 C++ 的误区 

9.4.1 类层次过细 

9.4.2 滥用操作符重载 

9.4.3 滥用标准容器 

9.4.4 滥用动态类型识别和异常 

9.4.5 滥用多重继承 

9.4.6 忽视C++高级特性的复杂度 

9.4.7 学习C++ 

9.5 动态内存分配的优化 

9.5.1 另一种优化策略：多次分配，一次释放 

9.5.2 垃圾回收 

9.5.3 再论动态内存分配 

9.6 template 

9.6.1 封装C++的成员函数调用 

9.6.2 常数数量的对象复制 

9.6.3 对象计数 

9.6.4 避免重复代码 

9.6.5 选择最佳的容器 

9.6.6 延迟运算 

9.6.7 编译时计算的游戏 

9.7 小结 

第10章 调试 

10.1 assert及程序错误的提前发现 

10.1.1 崩溃的程序不说谎 

10.1.2 为软件维护多个版本 

10.1.3 前置条件和后置条件 

10.1.4 自己实现一个assert 

10.1.5 不正确的assert使用 

10.1.6 为assert分级 

10.1.7 assert的引申：检查函数返回值 

10.1.8 释放的指针需要置空吗 

10.2 让程序更利于调试 

10.2.1 录像 

10.2.2 实现一个log类 

10.2.3 跟踪代码运行的流程 

10.2.4 为内存分配加上一个壳 

10.3 RELEASE版本的调试 

10.4 小结 

第11章 脚本 

11.1 为什么需要脚本 

11.2 应该用脚本做些什么 

11.3 脚本不应该做什么 

11.4 如何嵌入脚本语言 

11.5 选择一种脚本语言 

11.6 实战嵌入式脚本Lua 5 

11.6.1 嵌入Lua 

11.6.2 使用coroutine驱动游戏逻辑 

11.6.3 封装C++中的对象 

11.6.4 回调机制 

11.7 反外挂技术 

11.7.1 防止加速器 

11.7.2 防止分析伪造网络包 

11.7.3 防止逆向工程 

11.7.4 防止代码钩子 

11.7.5 惩戒外挂作弊者 

11.7.6 安全地将信息传递给服务器 

11.7.7 防止模拟输入 

第12章 版本控制 

12.1 常用版本控制软件 

12.2 版本控制工具在项目中的使用 

12.3 不仅仅是程序才需要 

第13章 开发方法 

13.1 失败的经验 

13.2 成功的经验 

13.3 对游戏开发方法的一些思考 

第14章 编程和游戏 

14.1 操作 

14.2 角色设定 

14.3 再谈技术 

14.4 浅谈网络游戏 

14.5 小结 
